/*
 * Blinking LED: the hardware version of Hello World
 *
 * Copyright: 2013, Technical University of Denmark, DTU Compute
 * Author: Martin Schoeberl (martin@jopdesign.com)
 * 
 */

import chisel3._
import chisel3.util._

/*
class Hello extends Module {
  val io = IO(new Bundle {
    val led = Output(UInt(4.W))
    val sw = Input(UInt(4.W))
  })

  
  val CNT_MAX = (1000000 / 2 - 1).U
  
  // Create counter reg.
  val cntReg = RegInit(0.U(32.W))

  // Create blink state reg.
  val blkReg = RegInit(0.U(1.W))

  // Increment counter
  cntReg := cntReg + 1.U

  // When the counter reaches max
  when(cntReg === CNT_MAX) {

    // Reset counter
    cntReg := 0.U

    // Flip the state of the blink state reg.
    blkReg := ~blkReg

  }

  // Init a default state.
  io.led := 0.U

  // Switch statement which selects which LED to blink
  switch(io.sw){
    is(0.U) { 
      when(blkReg === 0.U) {
        io.led := "b0000".U
      }
    }
    is(1.U) { 
      when(blkReg === 1.U) {
        io.led := "b0001".U
      }
    }
    is(2.U) { 
      when(blkReg === 1.U) {
        io.led := "b0010".U
      }
    }
    is(3.U) { 
      when(blkReg === 1.U) {
        io.led := "b0011".U
      }
    }    
    is(4.U) { 
      when(blkReg === 1.U) {
        io.led := "b0100".U
      }
    }
    is(5.U) { 
      when(blkReg === 1.U) {
        io.led := "b0101".U
      }
    }    
    is(6.U) { 
      when(blkReg === 1.U) {
        io.led := "b0110".U
      }
    }    
    is(7.U) { 
      when(blkReg === 1.U) {
        io.led := "b0111".U
      }
    }    
    is(8.U) { 
      when(blkReg === 1.U) {
        io.led := "b1000".U
      }
    }    
  }


}
class lol(length: UInt) extends Module{
  
  val io = IO(new Bundle {
    val a = Input(UInt(4.W))
    val b = Input(Wire(Vec(length, UInt(length.W) )))
    val c = Output(UInt(4.W))
  })
  io.c := length * io.a 
}*/

class I2S_Peripheral(width: UInt) extends Module {

  val io = IO(new Bundle {
    val sample =  Input(UInt(32.W))
    val feedNow = Input(UInt(1.W))
    val sampled = Output(UInt(1.W))
    val dmyOut =  Output(UInt(32.W))
    val dmydOut = Output(UInt(1.W))
    val dumbClk = Input(UInt(1.W))
    val cloneLR = Output(UInt(1.W))
    val sw =      Input(UInt(8.W))
  })
  
  // Define registers
  val ClkCntr = RegInit(0.U(8.W))
  val Tckr    = RegInit(0.U(1.W))
  val CloneLR = RegInit(0.U(1.W))
  val DmyOut  = RegInit(0.U(32.W))
  val DmydOut = RegInit(0.U(1.W))

  // Register transmitter module
  val transmitter = Module(new I2S_Transmitter(width))
  
  when (io.dumbClk === 1.U) {
    // Increment clk counter
    ClkCntr := ClkCntr + 1.U 
  }

  // Populate input register of the transmitter
  // transmitter.io.Tx := io.sample
  transmitter.io.Tx := io.sw


  // Clock divider:
  when(ClkCntr === 1.U) { //71.U) {
    // Send tick to transmitter
    Tckr := 1.U 
    // Reset Counter
    ClkCntr := 0.U
    // Every tick, populate output register w. current transmitter value.
    DmydOut := transmitter.io.bDATA
  }

  when(Tckr === 1.U) {
    CloneLR := transmitter.io.LRCLK
    DmyOut := transmitter.io.DATA
  }
  
  // Set outputs according to registers.
  transmitter.io.tick := Tckr
  io.cloneLR          := CloneLR
  io.dmyOut           := DmyOut
  io.dmydOut          := DmydOut

  // Register 'ready' from transmitter.
  // Intended to use to trigger a refill of the Tx register.. not the case rn.
  when (transmitter.io.Ready === 1.U) {
    io.sampled := 1.U
  }.otherwise {
    io.sampled := 0.U
  }
}


class I2S_Transmitter(width: UInt) extends Module {
  val io = IO(new Bundle {
    val Tx = Input(UInt(32.W))
    val Ready = Output(UInt(1.W))
    val LRCLK = Output(UInt(1.W))    
    val BCLK = Output(UInt(1.W))  
    val DATA = Output(UInt(32.W))
    val bDATA = Output(UInt(1.W))      
    val State_o = Output(UInt(2.W))
    val BitCntr = Output(UInt(8.W))
    val tick = Input(UInt(1.W))
  })

  // Define state enum.. case sentitive!
  val state_Reset :: state_TransmitWord :: Nil = Enum(2)
  // Init the current state
  val current_state = RegInit(state_Reset)  
  // Create counter reg. and Init = 0
  val Bit_Counter =   RegInit(0.U(8.W))

  val TxReg = RegInit(0.U(width))
  
  io.BitCntr := Bit_Counter
  
  // Init Outputs
  io.Ready := 0.U  
  io.LRCLK := 0.U
  io.BCLK  := 0.U
  io.DATA  := 0.U
  io.bDATA  := 0.U
  io.State_o := 0.U

  when (io.tick === 1.U) {

    switch(current_state){

      is(state_Reset) {

        io.State_o  := 0.U
        io.Ready    := 0.U
        io.LRCLK    := 0.U
        io.DATA     := 0.U
        Bit_Counter := 0.U
        io.BitCntr  := 0.U
        current_state := state_TransmitWord

      }

      is(state_TransmitWord) {

        io.State_o := 1.U

        // Below, ensures 1 bit delay. 
        when ((Bit_Counter === 0.U) || (Bit_Counter <= width - 1.U)){
          io.bDATA := (io.Tx((width - 1.U) - Bit_Counter))
          io.DATA := (io.Tx)
        }
        
        // If we're halfway through (ie. 2nd. channel)
        when (Bit_Counter >= ((width / 2.U) - 1.U)) {
          // Then set LRCLK high.
          io.LRCLK := 1.U
        }
        when ((Bit_Counter < ((width / 2.U) - 1.U)) || (Bit_Counter === (width - 1.U))) {
          // Else have the LRCLK low.
          io.LRCLK := 0.U
        }       

        // Reset bit counter when a full frame has been transmitted.
        when (Bit_Counter === (width - 1.U)) {
          Bit_Counter := 0.U
          io.Ready := 1.U
        } 
        .otherwise
        {
          // Just count the bits..
          Bit_Counter := Bit_Counter + 1.U     
        }
      }
    }
  }
}

/**
 * An object extending App to generate the Verilog code.
 */
object HelloMain extends App {
  println("Hello World, I will now generate the Verilog file!")
  //emitVerilog(new Hello())
  emitVerilog(new I2S_Peripheral(32.U))
}
